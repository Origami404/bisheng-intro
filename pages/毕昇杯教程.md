- 项目本体相关的 TODO
  collapsed:: true
	- 考虑统一主语的意义? 目前本页面中的 "我" 均指 HITsz 2022 年参赛的萝杨空队 #TODO
- 总览
  collapsed:: true
	- 做什么
	  collapsed:: true
		- SysY -> ARMv7
		- 源语言特性: (2022)
		  collapsed:: true
			- int/float 两种类型
			- 加减乘除模运算表达式
			- 分离的比较表达式
				- 比较只能在控制结构的条件里用, 不能嵌入到普通表达式中
				- 要做短路
			- 表达式里对 int 和 float 采取相同的 op, 需要做合理的类型推断和隐式转换的插入
			- if 和 while 控制结构
			- 函数
				- 会调用外部函数
					- 外部函数作为静态链接库被链接
					- 基本上是 IO 函数
				- 不会被外部函数调用
			- 数组
				- 数组会作为函数 (包括一些外部函数) 的参数被传递, 此时会退化为指针
				- 语言中没有指针的概念
				- 有全局数组和局部数组 (栈上的)
				- 数组初始化器语法处理起来很烦
		- 目标语言特性:
		  collapsed:: true
			- 相对比较精简的指令集
			- 整数和跳转和调用约定可以参考我的博客
			- 完整的对汇编的理解可以参考这本书
			- SIMD 和向量化的使用 #TODO
	- 怎么做 (比赛/赛程相关)
	  collapsed:: true
		- (可选) 加群: HITsz 毕昇杯招新群
		- 找队友
		  collapsed:: true
			- 推荐配置: 2-3 人
			- 优秀要求:
				- 熟悉 git, 知道 add/commit/push/pull/merge/rebase
				- 熟悉 Linux 操作, 能写点小脚本
				- 熟悉 C++, 不害怕巨大项目
					- 如果是预计使用 Java 开发的话, 还要熟悉 Java
					- C++ 必须会看, 因为 LLVM 将会是主要的参考对象
					- C++ 14 或以上, Java 15
				- 知道多趟编译器的基本架构和想要使用的 IR 的描述
			- 基本要求:
				- 至少有一个人会使用 git 解决冲突, 其他人都会 git add/commit/push/pull
				  :LOGBOOK:
				  CLOCK: [2023-01-03 Tue 17:58:55]--[2023-01-03 Tue 17:58:55] =>  00:00:00
				  :END:
				- 至少有一个人会用 qemu 和 gdb-remote, 或者有一个人能配一个 CI
				- 至少有一个人熟悉 C++, 其他人学过 C++/Java, 能写一百行以内的小程序
				- 至少有一个人跟过一些编译器的教程做过真的编译器
					- 源语言多大多小无所谓, 特性应该也无所谓, 图灵完备就行
					- 学校 2022 年的编译原理实验在看懂框架代码的基础上只能非常勉强地符合这个要求
						- 但是做过的人至少可以被另一个会的人快速教导
					- 只做过解释器应该是不够的
					- 只做过编译到某个 VM 的 bytecode 上面的编译器的话, 后端部分可能要折磨一点
			- 分工推荐:
				- 1 人:
					- 能进复赛就是成功
						- 除非您有丰富的编译器相关经验, 否则一人干活能进复赛就是很强的了
						- 想要拼二等奖都比较难
					- 如果您如此地强, 可以试试玩点花活
					- 如果您比较想要拿个奖
						- 推荐直接使用 TAC IR, 这样前端和后端都比较方便
						- 优化上做点常数折叠和到达定值分析时间应该就差不多了
				- 2 人:
					- 前端: 负责源代码 -> IR 及其优化
					- 后端: 负责 IR -> 汇编及其优化
					- 两个人在开始的一个月里要密切沟通, 把 IR 和基建做出来
				- 3 人:
					- 前端: 负责源代码 -> IR 及其优化
					- 优化: 负责 IR 上的优化和基建
					- 后端: 负责 IR -> 汇编及其优化
					- 强的话前期可以把自动向量化的基建做了, 后期让优化手负责自动向量化
				- 4 人: 暂时没见过, 不清楚
		- 报名参赛
		  collapsed:: true
			- **提前想好一个炫酷的队名!**
			- 每年大概暑假之前会要求报名
			- 想参赛记得跟老师说说, 要指导教师的
			- 报名需要各个队员的信息和指导老师
				- 信息填个 excel 表
				- 要学生证/饭卡和指导教师工作证扫描
				- 需要一个快递地址来收组委会送的树莓派
			- ~~隐藏信息~~
				- 组委会也有拖延症, 如果你什么东西填错了, 其实过了网页上的 DDL 很久之后也都可以改, 比赛大群里说就可以了; 同理, 如果你过了 DDL 才吸收队员/决定报名参赛什么的, 大群里说说说不定也能报上
				- 不过还是早点准备好比较好吧
		- 写代码
		  collapsed:: true
			- 这个应该在报名参赛之前就开始写!
			- 越早开始越好
			- 什么? 你说理论学习? 在你知道毕昇杯的时候就应该开始学!
				- 当然, 参赛过程中可以开始大量学习, 但是不能是太基础的那种东西
				- 我在参赛的时候学了:
					- LLVM IR 的内存形式和代码结构
					- SSA 上的优化的实现
					- SSA 生成相关的一些资料和论文
					- 如果你要做自动向量化的话, 这时候应该看一些论文什么的来实现特定的策略
		- 收到树莓派
		  collapsed:: true
			- 可以开始搭建 CI 或者测试环境什么的
			- 不过还是本地 qemu 比较方便
		- 官方评测机上线
		  collapsed:: true
			- 这个时候开发进度应该到本地能跑通全部功能样例了
			- 我们这时候有些性能样例还只能编译过, 运行完全 TLE
			- 赶紧看看评测命令和要求
			- 如果开发不是在官方 gitlab 上的, 迁移之
			- 尽快成功运行第一次
			- 据说 21 年的时候评测机很卡, 但是 22 年的感觉还行, 大概半小时能出一次结果
		- 初赛截止
		  collapsed:: true
			- 这时候应该差不多都做完了才行 (所有公开性能样例都能跑出时间, 相对较快)
			- 后面的时间最多补几个小优化 + 进行一些针对样例的优化
			- 可以开始脑子里准备一下答辩 PPT 了
		- 复赛截止
		  collapsed:: true
			- 开始做答辩 PPT 吧
		- 答辩完成
		- 出分出榜
	- 为什么要参赛?
	  collapsed:: true
		- 2022 - 萝杨空队 - 梁韬
			- 最初想要参赛, 主要是想做一个正儿八经的从头到尾的编译器
			- 之前有做过一些解释器, 有看过很多编译方面的书, 但是没有做过正经的编译器
			- 学了一些 PL 和类型论方面的东西, 感到基础不牢固了, 需要做一个编译器来更好地理解各类语言和语言上的构造以及设施
			- 并不是很专注于拿奖
				- 如果以拿奖为目标的的话, 我应该再晚一年参赛的, 这样把握比较大, 时间也比较充裕
			- 不后悔在当时参加了这场比赛
				- 虽然可能我那时能力有限, 没能做出向量化之类的东西
				- 但是我也得以深入地理解了编译器的流程, 得以熟悉了 LLVM 的冰山一角
				- 对我后面的职业规划和作为编译领域的程序的职业发展产生了巨大影响
	- 参赛完了能做什么?
	  collapsed:: true
		- 拿奖了就有华为绿卡
			- 不过好像职位看起来并不是很好就是了 (
		- 更深入地学习 LLVM, 开始尝试给 LLVM 共享代码
			- 广告: PLCT 提供一些编译器相关领域的远程实习岗位
			- 字节之类的大厂有一些编译领域相关的岗位, 可以关注一下
		- 来贡献本文档 :)
- 编译器结构总览
  collapsed:: true
	- 2022 萝杨空队
		- 我们到比赛完结之后的结构
		- ![Untitled-2022-08-20-2159.svg](../assets/Untitled-2022-08-20-2159_1672756081358_0.svg)
		- 如果能让我重新设计, 我会把它变成这样:
		- ![renewed-sturcture.svg](../assets/renewed-sturcture_1672756210550_0.svg)
		- 我要在 SSA 构建的时候大量使用 Load/Store, 后期再一起做 mem2reg (因为反正不管怎么样内存分析都是要做的), 这样可以极大简化前端生成的工作量
		- 内存分析能再来一次的话我绝对使用 Memory SSA 而不是自己手戳的不知道什么玩意
- 编译器代码设计常见抉择
	- 运行时类型识别
		- 编译器编写中经常需要接管实现语言的类型系统, 做自己的 "类型识别"
			- 比如很多时候你会想要 "让 IAdd 指令和 ISub 指令不是相同的类型", 尽管它们在实现上是实现语言里相同的一个 class
			- 它不同于 equality, 简单地对 `operator=` 或是 `equals` 的重载并不能很好地区分这个东西
			- 你需要在运行时判断它们
		- 实现多态的方法有几种:
			- C++
				-
	- 自建数据结构
		- 双向链接
		  collapsed:: true
			- 编译器设计中有很多地方需要双向链接
			- 有些双向链接是相互的
				- 很多时候需要从一个对象出发, 找到使用了它作为参数的对象
				- 更多时候需要从一个对象出发, 找到这个对象使用了哪些对象作为参数
				- 处理手段: 存两份
					- 来一个 User 类保存一个 Object 数组, 记录这个 Object 用了哪些其他 Object
					- 来一个 Usee 类保存一个 Object 数组, 记录这个 Object 被哪些其他 Object 使用
					- 只通过 User/Usee 的 API 操作 Object 关系, 保证它们是统一的
					- Usee 类通常就是 Value 类
			- 有些双向链接是树状的
				- 比如一个基本块里有很多指令, 我们要能遍历这些指令
				- 但是我们经常也需要知道指令属于哪个基本块
				- 处理手段: 侵入式链表
		- 侵入式链表
		  collapsed:: true
			- 指链表里放的对象要做特殊处理的链表
			- 普通链表里啥都能放, 但是
				- 需要使用迭代器之类的对象访问跟链表有关的东西
				- 比如只有当你有一个迭代器, 你才可以拿到链表里上一个/下一个元素
				- 任何跟链表有关的信息只能放链表/迭代器里
			- 在编译器中经常会出现这样的需求
				- 从链表中放的对象里直接拿到放链表的对象
					- 比如从指令直接拿到存着它的基本块
				- 从链表中放的对象里直接拿到链表里附近的对象
					- 比如从一条指令里直接拿到它的下一条指令是什么
				- 一边访问, 一边修改
					- 这并不需要一定是侵入式链表才能做到
					- 但是你自己做的侵入式链表最好支持这个, 要不然用起来会很难用
					- 很多时候都会干这事, 比如你遍历一个基本块的指令, 然后做点去重什么的
					- 只需要保证在访问到 A 点的时候, 如果删除了未来要访问的 B, 那么接下来的 for 循环访问不到 B 就可以了, 实现上还是应该也许挺好实现的吧...
			- 你最好自己写一个侵入式链表
				- 参考: LLVM 的 [simple_ilist](https://llvm.org/doxygen/classllvm_1_1simple__ilist.html) 类
					- LLVM 的这个类因为各种原因实现得很复杂, 对于毕昇杯参赛用的项目而言并不需要一模一样复刻一个
					- 它是让链表元素可以获得指向自己的迭代器来支持上面的操作的, 实际上我们可以直接偷懒在 `inode` 里就写一些访问前前后后的方法的
					- 不过反正都要写一个迭代器类来做 range-for 的, 也许它这样实现反而省代码一点
				- 在 C++ 里, 我们有多重继承, 所以可以做成这样的:
					- #TODO
				- 在 Java 里, 我们没有 class 的多重继承... 但是我们有带 default 方法的 interface !
					- 可以迂回地实现, 需要四个类 + 一些不好玩的代码
					- #TODO
		- 自定义的对象位置的指针
		  collapsed:: true
			- 当我们在对程序做优化的时候, 通常会去统一把某个 Object 替换掉
				- 这个替换通常实现在 Usee 类里, 将自己从其他 Object 的参数里替换成另一个 Object
			- 但是这样很有可能导致指针 "失效"!
				- 很多时候我们靠指针/对特定 Object 的引用来指代某个位置上的对象
				- 我们并不是需要那个特定的 Object, 但是我们需要的是那个位置上的一个 Object
				- 举个例子 #TODO
				- 缓解手段: 计算, 而不是缓存
					- 能算就算, 不要存着. 存着就有可能导致失效, 现算就永远不会.
					- 比如能通过对象 getter 拿那就拿, 不要先在函数里开个局部变量存着
					- 要特别小心各种数据结构里存着的对象, 多问问自己当这个对象被存进去之后, 如果它被别的优化过程替换掉了, 或者它的参数被别的优化过程替换了, 它会怎么样
						- 尤其是, 当你的 Value 之类的对象的 hash 函数依赖参数的时候!
						- **不要让 hash 方法依赖任何可变的对象成员! 谁踩坑谁知道!**
				- 解决手段:  再来一层抽象
					- 写一个 ValueHandler 之类的指针类似物
					- 然后把 ValueHandler 也当成 Usee
					- 不过要注意一些约束是否还会被满足
						- 比如当你把一个对象从所有 IR 里都替换掉了, 你可能会认为此时对象应该没有 User 了
						- 但是它可能还在你的代码里的某个地方存着
	- 所有权与内存管理 (C++)
		- 可能需要 C++ 用户辅助编写 #TODO
- 自动向量化
  collapsed:: true
	- 本节主要分析自动向量化需要的基建和它对 IR 结构的影响
	- 我们没做, 基本上不会, 需要进一步学习 #TODO
- Parser 及其生成
  collapsed:: true
	- 忘掉你学的一堆 LR 什么乱七八糟的玩意, 我们从不手写那些东西. 任何头脑正常的编译器开发者都会选择手写递归下降或使用解析器生成器
	- Lex/Yacc (Flex/Bison)
		- 你也许已经在很多教科书里听过它们的鼎鼎大名了
		- 你现在能装到的现代实现是 GNU 的 Flex (对应 lex) 和 Bison (对应 yacc), 使用上大同小异
		- 完整的一个小 demo 可以看 `codes/yacc-demo` #TODO
		- 不过它有一些缺点
			- 错误提示比较难猜
				- 只会告诉你哪里有什么移入冲突规约冲突, 偶尔可以给出能导致冲突的例子
				- 我的评价是: 实际上生成规则表的又不是我, 我怎么猜得出为什么有冲突
			- 跟 C/C++ 项目的交互方式有点难懂
				- 反正我是学了好一阵子才学会怎么用
		- 根据组委会评测机的编译要求, 你是要把它生成的各个 C/C++ 源文件和头文件加到 VCS 里去的, 所以晚加不如早加吧. 虽然理论上这种生成出来的文件, 按照一般项目的规则最好是不要加到 VCS 里的来着.
	- ANTLR
		- 目前的版本是 ANTLR 4, 跟 ANTLR 3 有一定区别, 查资料的时候不要弄混了
			- ANTLR 有 runtime 的, 在官方评测机出来之后要注意一下看用的 ANTLR 版本是不是一致的
			- 2022 年官方评测机上面的版本我没记错的话是 `4.8.3`
		- ANTLR 3 有树重写功能, 可以一键生成 AST; ANTLR 4 给砍了
			- 不过对于 SysY 这种复杂程度的语言而言, 树重写有些不够看了
				- 我两个都试过, 相信我, 这个看起来很好用的功能实际上并不那么好用
				- 自动出出来的 AST 到头来你还是得写 visitor; 不出 AST 的话你就要退化到跟 yacc 一样把前端夹杂在语法文件里的境地, 都不好玩
				- 而且让它自动出 AST 意味着你没办法往 AST 结构上方便地加成员
					- 不过一般也不用加就是了
		- 因为只有一个库, 所以应该不值得用什么构建工具/管理器
			- 反正官方评测机那边也是没有构建工具的, 直接给你全部文件一起编译链接了完事
		- 一个 ANTLR + Java 的例子在 `codes/antlr-java` #TODO
		- 一个 ANTLR + C++ 的例子在 `codes/antlr-cpp` #TODO
			- 这个我没写过, 需要帮助
	- 手写递归下降
		- 不推荐, 很无聊
		- 只有需要详细的对源程序的诊断信息的编译器才值得来一个手写递归下降, 而毕昇杯根本不需要这个
- IR 基础
  collapsed:: true
	- IR, 就是编译器里用来保存程序信息的中心数据结构
	- 任何一种 IR 形式, 它的核心都在于它是怎么样一个数据结构. 不同的 IR 之间的区别就像 `std::vector` 和 `std::list` 一样. 它们支持不同的高效操作, 从而支持不同层面的对源程序的分析和变换
	- 常见的 IR 形式
	  collapsed:: true
		- 指令级别
			- 三地址 TAC
			- 静态单赋值 SSA
		- 基本块级别
			- 基本上都是指令的列表
			- SSA 相关
				- phi 指令
				- 基本块参数
		- 函数级别
			- 基本上都是基本块的列表
			- Continuation passing style / CPS
				- 除非你有丰富的编译器开发经验和函数式编程经验, 或者已经知道 continuation 是什么, 否则不建议使用此种形式的 IR
				- 它跟源语言的性质不太相合
				- 但是如果你恰好水平很高, 可以拿它玩花活, 我挺想看有大佬能对 C 系语言做到 CPS 的构建的, ~~我还不会呢~~
	- [[Three Address Code IR]] 介绍
		- 跟 HITsz 2022 届编译原理实验课实验框架里的 IR 一样
		- #TODO
	- SSA 介绍
		- 主要参考: LLVM IR 和 GraalVM 的 IR
		- #TODO
- SSA 构建
  collapsed:: true
	- Memory + Load/Store (推荐)
		- 对源语言里的每一个变量, 在栈上分配一个内存位置
		- 每次读就使用一条 Load 指令, 写就使用一条 Store 指令
		- 好处:
			- 统一了变量和数组的处理, 大伙都是指针, 区别只是你偏移多少而已
				- 你可以将 `int a` 视作 `int a[1]`
				- 也可以像 LLVM 一样, 将数组视作原始类型, 跟指针彻底分开, 源语言中的数组翻译成指向数组的指针, 这样大家就都要叠一层 `gep 0`
			- 前端完全不用管什么破 SSA 性质, 跟生成 TAC 一样生成就行了, 简单得很呐
			- 前端生成的 IR 里可以带很多 debug 信息, 比如给每个 alloc 绑定上源语言里的变量名, 输出出来可以很好看
		- 坏处:
			- 显然性能是糟糕的
				- 但是, 但是! 你在后面的优化里, 可以完全处理掉这些没用的 Alloc/Load/Store
				- 如果你做了正常的内存分析, 它完全可以直接纠正掉你引入的所有额外内存访问
					- 还能顺路处理掉源语言里就有的内存访问
	- 对结构化的语言, 可以直接在前端分析出 phi 的参数 (我们的做法, 不推荐)
		- 不推荐的理由:
			- 这个分析的逻辑你在后面的内存分析的优化里还要再写一次的, 在前端处理这个没有必要, 只是单纯复杂化前端的写法而已
				- 如果你写的是 SDT 之类的一趟编译器, 这个综合起来的写法可能还有价值
				- 但是谁写一趟编译器还要输出 SSA 啊...?
					- 可能有人会写 C -> Haskell 之类的从有变量的语言到不可变语言的一趟翻译器, 可能这时候有价值吧
					- 别的情况我实在编不出来了
					- 别这样写, Just don't do that.
			- 会导致前端里变量和数组的处理不统一, 很烦啊
			- 编译器前端本身的性能可能会有问题
				- 不过应该不大
		- 我们的实现基本上就是 mem2reg 的 ((63b4d809-af7b-4880-85ac-d93ce649bf42))
- 内存分析
  collapsed:: true
	- mem2reg
		- 基于直觉的算法 #TODO
		  id:: 63b4d809-af7b-4880-85ac-d93ce649bf42
		- 基于支配关系的算法 #TODO
	- Memory SSA
		- 它并不是一个单独的, 表示源语言的程序的 IR, 而是一个 IR 的 IR
		- 它相当于在现有 SSA IR 的 alloc 上再覆盖一层 SSA, 用来分析一块内存什么时候被动过
		- 它的目的很显然
			- 对于没动过的内存, 我们就可以复用已有的 Load
			- 所以它就是拿来分析内存有没有被 Store 过的
		- #TODO
- SSA 上的优化
  collapsed:: true
	- 建议参考项目中的文档
	- #TODO 给出链接并完善项目中的文档
- TAC 构建
  collapsed:: true
	- Phi destruction #TODO
- 寄存器分配
  collapsed:: true
	- 栈空间分配 #TODO
	- 基础图着色 #TODO
	- 图着色上的优化 #TODO
- TAC 上的优化
  collapsed:: true
	- 特殊指令的使用 #TODO
	- 条件执行 #TODO
- 汇编生成 #TODO
  collapsed:: true
	- 这个好像比较简单, 不知道要不要单独拉出来讲